import {
  __commonJS
} from "./chunk-76J2PTFD.js";

// node_modules/repeat-string/index.js
var require_repeat_string = __commonJS({
  "node_modules/repeat-string/index.js"(exports, module) {
    "use strict";
    var res = "";
    var cache;
    module.exports = repeat;
    function repeat(str, num) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      if (num === 1)
        return str;
      if (num === 2)
        return str + str;
      var max = str.length * num;
      if (cache !== str || typeof cache === "undefined") {
        cache = str;
        res = "";
      } else if (res.length >= max) {
        return res.substr(0, max);
      }
      while (max > res.length && num > 1) {
        if (num & 1) {
          res += str;
        }
        num >>= 1;
        str += str;
      }
      res += str;
      res = res.substr(0, max);
      return res;
    }
  }
});

// node_modules/markdown-table/index.js
var require_markdown_table = __commonJS({
  "node_modules/markdown-table/index.js"(exports, module) {
    "use strict";
    var repeat = require_repeat_string();
    module.exports = markdownTable;
    var trailingWhitespace = / +$/;
    var space = " ";
    var lineFeed = "\n";
    var dash = "-";
    var colon = ":";
    var verticalBar = "|";
    var x = 0;
    var C = 67;
    var L = 76;
    var R = 82;
    var c = 99;
    var l = 108;
    var r = 114;
    function markdownTable(table, options) {
      var settings = options || {};
      var padding = settings.padding !== false;
      var start = settings.delimiterStart !== false;
      var end = settings.delimiterEnd !== false;
      var align = (settings.align || []).concat();
      var alignDelimiters = settings.alignDelimiters !== false;
      var alignments = [];
      var stringLength = settings.stringLength || defaultStringLength;
      var rowIndex = -1;
      var rowLength = table.length;
      var cellMatrix = [];
      var sizeMatrix = [];
      var row = [];
      var sizes = [];
      var longestCellByColumn = [];
      var mostCellsPerRow = 0;
      var cells;
      var columnIndex;
      var columnLength;
      var largest;
      var size;
      var cell;
      var lines;
      var line;
      var before;
      var after;
      var code;
      while (++rowIndex < rowLength) {
        cells = table[rowIndex];
        columnIndex = -1;
        columnLength = cells.length;
        row = [];
        sizes = [];
        if (columnLength > mostCellsPerRow) {
          mostCellsPerRow = columnLength;
        }
        while (++columnIndex < columnLength) {
          cell = serialize(cells[columnIndex]);
          if (alignDelimiters === true) {
            size = stringLength(cell);
            sizes[columnIndex] = size;
            largest = longestCellByColumn[columnIndex];
            if (largest === void 0 || size > largest) {
              longestCellByColumn[columnIndex] = size;
            }
          }
          row.push(cell);
        }
        cellMatrix[rowIndex] = row;
        sizeMatrix[rowIndex] = sizes;
      }
      columnIndex = -1;
      columnLength = mostCellsPerRow;
      if (typeof align === "object" && "length" in align) {
        while (++columnIndex < columnLength) {
          alignments[columnIndex] = toAlignment(align[columnIndex]);
        }
      } else {
        code = toAlignment(align);
        while (++columnIndex < columnLength) {
          alignments[columnIndex] = code;
        }
      }
      columnIndex = -1;
      columnLength = mostCellsPerRow;
      row = [];
      sizes = [];
      while (++columnIndex < columnLength) {
        code = alignments[columnIndex];
        before = "";
        after = "";
        if (code === l) {
          before = colon;
        } else if (code === r) {
          after = colon;
        } else if (code === c) {
          before = colon;
          after = colon;
        }
        size = alignDelimiters ? Math.max(
          1,
          longestCellByColumn[columnIndex] - before.length - after.length
        ) : 1;
        cell = before + repeat(dash, size) + after;
        if (alignDelimiters === true) {
          size = before.length + size + after.length;
          if (size > longestCellByColumn[columnIndex]) {
            longestCellByColumn[columnIndex] = size;
          }
          sizes[columnIndex] = size;
        }
        row[columnIndex] = cell;
      }
      cellMatrix.splice(1, 0, row);
      sizeMatrix.splice(1, 0, sizes);
      rowIndex = -1;
      rowLength = cellMatrix.length;
      lines = [];
      while (++rowIndex < rowLength) {
        row = cellMatrix[rowIndex];
        sizes = sizeMatrix[rowIndex];
        columnIndex = -1;
        columnLength = mostCellsPerRow;
        line = [];
        while (++columnIndex < columnLength) {
          cell = row[columnIndex] || "";
          before = "";
          after = "";
          if (alignDelimiters === true) {
            size = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0);
            code = alignments[columnIndex];
            if (code === r) {
              before = repeat(space, size);
            } else if (code === c) {
              if (size % 2 === 0) {
                before = repeat(space, size / 2);
                after = before;
              } else {
                before = repeat(space, size / 2 + 0.5);
                after = repeat(space, size / 2 - 0.5);
              }
            } else {
              after = repeat(space, size);
            }
          }
          if (start === true && columnIndex === 0) {
            line.push(verticalBar);
          }
          if (padding === true && // Don’t add the opening space if we’re not aligning and the cell is
          // empty: there will be a closing space.
          !(alignDelimiters === false && cell === "") && (start === true || columnIndex !== 0)) {
            line.push(space);
          }
          if (alignDelimiters === true) {
            line.push(before);
          }
          line.push(cell);
          if (alignDelimiters === true) {
            line.push(after);
          }
          if (padding === true) {
            line.push(space);
          }
          if (end === true || columnIndex !== columnLength - 1) {
            line.push(verticalBar);
          }
        }
        line = line.join("");
        if (end === false) {
          line = line.replace(trailingWhitespace, "");
        }
        lines.push(line);
      }
      return lines.join(lineFeed);
    }
    function serialize(value) {
      return value === null || value === void 0 ? "" : String(value);
    }
    function defaultStringLength(value) {
      return value.length;
    }
    function toAlignment(value) {
      var code = typeof value === "string" ? value.charCodeAt(0) : x;
      return code === L || code === l ? l : code === R || code === r ? r : code === C || code === c ? c : x;
    }
  }
});

// node_modules/notion-to-md/build/utils/md.js
var require_md = __commonJS({
  "node_modules/notion-to-md/build/utils/md.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.table = exports.toggle = exports.divider = exports.addTabSpace = exports.image = exports.todo = exports.bullet = exports.callout = exports.quote = exports.heading3 = exports.heading2 = exports.heading1 = exports.equation = exports.codeBlock = exports.link = exports.underline = exports.strikethrough = exports.italic = exports.bold = exports.inlineEquation = exports.inlineCode = void 0;
    var markdown_table_1 = __importDefault(require_markdown_table());
    var inlineCode = (text) => {
      return `\`${text}\``;
    };
    exports.inlineCode = inlineCode;
    var inlineEquation = (text) => {
      return `$${text}$`;
    };
    exports.inlineEquation = inlineEquation;
    var bold = (text) => {
      return `**${text}**`;
    };
    exports.bold = bold;
    var italic = (text) => {
      return `_${text}_`;
    };
    exports.italic = italic;
    var strikethrough = (text) => {
      return `~~${text}~~`;
    };
    exports.strikethrough = strikethrough;
    var underline = (text) => {
      return `<u>${text}</u>`;
    };
    exports.underline = underline;
    var link = (text, href) => {
      return `[${text}](${href})`;
    };
    exports.link = link;
    var codeBlock = (text, language) => {
      if (language === "plain text")
        language = "text";
      return `\`\`\`${language}
${text}
\`\`\``;
    };
    exports.codeBlock = codeBlock;
    var equation = (text) => {
      return `$$
${text}
$$`;
    };
    exports.equation = equation;
    var heading1 = (text) => {
      return `# ${text}`;
    };
    exports.heading1 = heading1;
    var heading2 = (text) => {
      return `## ${text}`;
    };
    exports.heading2 = heading2;
    var heading3 = (text) => {
      return `### ${text}`;
    };
    exports.heading3 = heading3;
    var quote = (text) => {
      return `> ${text.replace(/\n/g, "  \n> ")}`;
    };
    exports.quote = quote;
    var callout = (text, icon) => {
      let emoji;
      if ((icon === null || icon === void 0 ? void 0 : icon.type) === "emoji") {
        emoji = icon.emoji;
      }
      return `> ${emoji ? emoji + " " : ""}${text.replace(/\n/g, "  \n> ")}`;
    };
    exports.callout = callout;
    var bullet = (text, count) => {
      let renderText = text.trim();
      return count ? `${count}. ${renderText}` : `- ${renderText}`;
    };
    exports.bullet = bullet;
    var todo = (text, checked) => {
      return checked ? `- [x] ${text}` : `- [ ] ${text}`;
    };
    exports.todo = todo;
    var image = (alt, href) => {
      return `![${alt}](${href})`;
    };
    exports.image = image;
    var addTabSpace = (text, n = 0) => {
      const tab = "	";
      for (let i = 0; i < n; i++) {
        if (text.includes("\n")) {
          const multiLineText = text.split(/(?:^|\n)/).join(`
${tab}`);
          text = tab + multiLineText;
        } else
          text = tab + text;
      }
      return text;
    };
    exports.addTabSpace = addTabSpace;
    var divider = () => {
      return "---";
    };
    exports.divider = divider;
    var toggle = (summary, children) => {
      if (!summary)
        return children || "";
      return `<details>
  <summary>${summary}</summary>

${children || ""}

  </details>`;
    };
    exports.toggle = toggle;
    var table = (cells) => {
      return (0, markdown_table_1.default)(cells);
    };
    exports.table = table;
  }
});

// node_modules/notion-to-md/build/utils/notion.js
var require_notion = __commonJS({
  "node_modules/notion-to-md/build/utils/notion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.modifyNumberedListObject = exports.getBlockChildren = void 0;
    var getBlockChildren = async (notionClient, block_id, totalPage) => {
      try {
        let result = [];
        let pageCount = 0;
        let start_cursor = void 0;
        do {
          const response = await notionClient.blocks.children.list({
            start_cursor,
            block_id
          });
          result.push(...response.results);
          start_cursor = response === null || response === void 0 ? void 0 : response.next_cursor;
          pageCount += 1;
        } while (start_cursor != null && (totalPage == null || pageCount < totalPage));
        (0, exports.modifyNumberedListObject)(result);
        return result;
      } catch (e) {
        console.log(e);
        return [];
      }
    };
    exports.getBlockChildren = getBlockChildren;
    var modifyNumberedListObject = (blocks) => {
      let numberedListIndex = 0;
      for (const block of blocks) {
        if ("type" in block && block.type === "numbered_list_item") {
          block.numbered_list_item.number = ++numberedListIndex;
        } else {
          numberedListIndex = 0;
        }
      }
    };
    exports.modifyNumberedListObject = modifyNumberedListObject;
  }
});

// node_modules/notion-to-md/build/notion-to-md.js
var require_notion_to_md = __commonJS({
  "node_modules/notion-to-md/build/notion-to-md.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NotionToMarkdown = void 0;
    var md = __importStar(require_md());
    var notion_1 = require_notion();
    var NotionToMarkdown = class {
      constructor(options) {
        this.notionClient = options.notionClient;
        const defaultConfig = {
          separateChildPage: false
        };
        this.targetPage = "";
        this.config = { ...defaultConfig, ...options.config };
        this.customTransformers = {};
      }
      setCustomTransformer(type, transformer) {
        this.customTransformers[type] = transformer;
        return this;
      }
      /**
       * Converts Markdown Blocks to string
       * @param {MdBlock[]} mdBlocks - Array of markdown blocks
       * @param {number} nestingLevel - Defines max depth of nesting
       * @returns {MdStringObject} - Returns markdown string with child pages separated
       */
      toMarkdownString(mdBlocks = [], pageIdentifier = "parent", nestingLevel = 0) {
        let mdOutput = {};
        mdBlocks.forEach((mdBlocks2) => {
          if (mdBlocks2.parent && mdBlocks2.type !== "toggle" && mdBlocks2.type !== "child_page") {
            if (mdBlocks2.type !== "to_do" && mdBlocks2.type !== "bulleted_list_item" && mdBlocks2.type !== "numbered_list_item") {
              mdOutput[pageIdentifier] = mdOutput[pageIdentifier] || "";
              mdOutput[pageIdentifier] += `
${md.addTabSpace(mdBlocks2.parent, nestingLevel)}

`;
            } else {
              mdOutput[pageIdentifier] = mdOutput[pageIdentifier] || "";
              mdOutput[pageIdentifier] += `${md.addTabSpace(mdBlocks2.parent, nestingLevel)}
`;
            }
          }
          if (mdBlocks2.children && mdBlocks2.children.length > 0) {
            if (mdBlocks2.type === "synced_block" || mdBlocks2.type === "column_list" || mdBlocks2.type === "column") {
              let mdstr = this.toMarkdownString(mdBlocks2.children, pageIdentifier);
              mdOutput[pageIdentifier] = mdOutput[pageIdentifier] || "";
              Object.keys(mdstr).forEach((key) => {
                if (mdOutput[key]) {
                  mdOutput[key] + mdstr[key];
                } else {
                  mdOutput[key] = mdstr[key];
                }
              });
              mdOutput[pageIdentifier] += mdstr[pageIdentifier];
            } else if (mdBlocks2.type === "child_page") {
              const childPageTitle = mdBlocks2.parent;
              let mdstr = this.toMarkdownString(mdBlocks2.children, childPageTitle);
              if (this.config.separateChildPage) {
                mdOutput = { ...mdOutput, ...mdstr };
              } else {
                mdOutput[pageIdentifier] += mdstr[childPageTitle];
              }
            } else if (mdBlocks2.type === "toggle") {
              const toggle_children_md_string = this.toMarkdownString(mdBlocks2.children);
              mdOutput[pageIdentifier] += md.toggle(mdBlocks2.parent, toggle_children_md_string["parent"]);
            } else {
              let mdstr = this.toMarkdownString(mdBlocks2.children, pageIdentifier, nestingLevel + 1);
              mdOutput[pageIdentifier] += mdstr["parent"];
            }
          }
        });
        return mdOutput;
      }
      /**
       * Retrieves Notion Blocks based on ID and converts them to Markdown Blocks
       * @param {string} id - notion page id (not database id)
       * @param {number} totalPage - Retrieve block children request number, page_size Maximum = totalPage * 100 (Default=null)
       * @returns {Promise<MdBlock[]>} - List of markdown blocks
       */
      async pageToMarkdown(id, totalPage = null) {
        if (!this.notionClient) {
          throw new Error("notion client is not provided, for more details check out https://github.com/souvikinator/notion-to-md");
        }
        this.targetPage = id;
        const blocks = await (0, notion_1.getBlockChildren)(this.notionClient, id, totalPage);
        const parsedData = await this.blocksToMarkdown(blocks);
        return parsedData;
      }
      /**
       * Converts list of Notion Blocks to Markdown Blocks
       * @param {ListBlockChildrenResponseResults | undefined} blocks - List of notion blocks
       * @param {number} totalPage - Retrieve block children request number, page_size Maximum = totalPage * 100
       * @param {MdBlock[]} mdBlocks - Defines max depth of nesting
       * @returns {Promise<MdBlock[]>} - Array of markdown blocks with their children
       */
      async blocksToMarkdown(blocks, totalPage = null, mdBlocks = []) {
        if (!this.notionClient) {
          throw new Error("notion client is not provided, for more details check out https://github.com/souvikinator/notion-to-md");
        }
        if (!blocks)
          return mdBlocks;
        for (let i = 0; i < blocks.length; i++) {
          let block = blocks[i];
          if ("has_children" in block && block.has_children) {
            let child_blocks = await (0, notion_1.getBlockChildren)(this.notionClient, block.id, totalPage);
            mdBlocks.push({
              type: block.type,
              blockId: block.id,
              parent: await this.blockToMarkdown(block),
              children: []
            });
            let l = mdBlocks.length;
            await this.blocksToMarkdown(child_blocks, totalPage, mdBlocks[l - 1].children);
            continue;
          }
          let tmp = await this.blockToMarkdown(block);
          mdBlocks.push({
            // @ts-ignore
            type: block.type,
            blockId: block.id,
            parent: tmp,
            children: []
          });
        }
        return mdBlocks;
      }
      /**
       * Converts a Notion Block to a Markdown Block
       * @param {ListBlockChildrenResponseResult} block - single notion block
       * @returns {string} corresponding markdown string of the passed block
       */
      async blockToMarkdown(block) {
        if (typeof block !== "object" || !("type" in block))
          return "";
        let parsedData = "";
        const { type } = block;
        if (type in this.customTransformers && !!this.customTransformers[type]) {
          const customTransformerValue = await this.customTransformers[type](block);
          if (!!customTransformerValue || customTransformerValue === "")
            return customTransformerValue;
        }
        switch (type) {
          case "image":
            {
              let blockContent = block.image;
              const image_caption_plain = blockContent.caption.map((item) => item.plain_text).join("");
              const image_type = blockContent.type;
              if (image_type === "external")
                return md.image(image_caption_plain, blockContent.external.url);
              if (image_type === "file")
                return md.image(image_caption_plain, blockContent.file.url);
            }
            break;
          case "divider": {
            return md.divider();
          }
          case "equation": {
            return md.equation(block.equation.expression);
          }
          case "video":
          case "file":
          case "pdf":
            {
              let blockContent;
              if (type === "video")
                blockContent = block.video;
              if (type === "file")
                blockContent = block.file;
              if (type === "pdf")
                blockContent = block.pdf;
              if (blockContent) {
                const file_type = blockContent.type;
                if (file_type === "external")
                  return md.link("image", blockContent.external.url);
                if (file_type === "file")
                  return md.link("image", blockContent.file.url);
              }
            }
            break;
          case "bookmark":
          case "embed":
          case "link_preview":
          case "link_to_page":
            {
              let blockContent;
              let title = type;
              if (type === "bookmark")
                blockContent = block.bookmark;
              if (type === "embed")
                blockContent = block.embed;
              if (type === "link_preview")
                blockContent = block.link_preview;
              if (type === "link_to_page" && block.link_to_page.type === "page_id") {
                blockContent = { url: block.link_to_page.page_id };
              }
              if (blockContent)
                return md.link(title, blockContent.url);
            }
            break;
          case "child_page":
            {
              let pageTitle = block.child_page.title;
              if (this.config.separateChildPage) {
                return pageTitle;
              }
              return md.heading2(pageTitle);
            }
            break;
          case "child_database":
            {
              let pageTitle = block.child_database.title || `child_database`;
              return pageTitle;
            }
            break;
          case "table": {
            const { id, has_children } = block;
            let tableArr = [];
            if (has_children) {
              const tableRows = await (0, notion_1.getBlockChildren)(this.notionClient, id, 100);
              let rowsPromise = tableRows === null || tableRows === void 0 ? void 0 : tableRows.map(async (row) => {
                const { type: type2 } = row;
                const cells = row[type2]["cells"];
                let cellStringPromise = cells.map(async (cell) => await this.blockToMarkdown({
                  type: "paragraph",
                  paragraph: { rich_text: cell }
                }));
                const cellStringArr = await Promise.all(cellStringPromise);
                tableArr.push(cellStringArr);
              });
              await Promise.all(rowsPromise || []);
            }
            return md.table(tableArr);
          }
          default: {
            let blockContent = block[type].text || block[type].rich_text || [];
            blockContent.map((content) => {
              if (content.type === "equation") {
                parsedData += md.inlineEquation(content.equation.expression);
                return;
              }
              const annotations = content.annotations;
              let plain_text = content.plain_text;
              plain_text = this.annotatePlainText(plain_text, annotations);
              if (content["href"])
                plain_text = md.link(plain_text, content["href"]);
              parsedData += plain_text;
            });
          }
        }
        switch (type) {
          case "code":
            {
              parsedData = md.codeBlock(parsedData, block[type].language);
            }
            break;
          case "heading_1":
            {
              parsedData = md.heading1(parsedData);
            }
            break;
          case "heading_2":
            {
              parsedData = md.heading2(parsedData);
            }
            break;
          case "heading_3":
            {
              parsedData = md.heading3(parsedData);
            }
            break;
          case "quote":
            {
              parsedData = md.quote(parsedData);
            }
            break;
          case "callout":
            {
              const { id, has_children } = block;
              let callout_string = "";
              if (!has_children) {
                return md.callout(parsedData, block[type].icon);
              }
              const callout_children_object = await (0, notion_1.getBlockChildren)(this.notionClient, id, 100);
              const callout_children = await this.blocksToMarkdown(callout_children_object);
              callout_string += `${parsedData}
`;
              callout_children.map((child) => {
                callout_string += `${child.parent}

`;
              });
              parsedData = md.callout(callout_string.trim(), block[type].icon);
            }
            break;
          case "bulleted_list_item":
            {
              parsedData = md.bullet(parsedData);
            }
            break;
          case "numbered_list_item":
            {
              parsedData = md.bullet(parsedData, block.numbered_list_item.number);
            }
            break;
          case "to_do":
            {
              parsedData = md.todo(parsedData, block.to_do.checked);
            }
            break;
        }
        return parsedData;
      }
      /**
       * Annoate text using provided annotations
       * @param {string} text - String to be annotated
       * @param {Annotations} annotations - Annotation object of a notion block
       * @returns {string} - Annotated text
       */
      annotatePlainText(text, annotations) {
        if (text.match(/^\s*$/))
          return text;
        const leadingSpaceMatch = text.match(/^(\s*)/);
        const trailingSpaceMatch = text.match(/(\s*)$/);
        const leading_space = leadingSpaceMatch ? leadingSpaceMatch[0] : "";
        const trailing_space = trailingSpaceMatch ? trailingSpaceMatch[0] : "";
        text = text.trim();
        if (text !== "") {
          if (annotations.code)
            text = md.inlineCode(text);
          if (annotations.bold)
            text = md.bold(text);
          if (annotations.italic)
            text = md.italic(text);
          if (annotations.strikethrough)
            text = md.strikethrough(text);
          if (annotations.underline)
            text = md.underline(text);
        }
        return leading_space + text + trailing_space;
      }
    };
    exports.NotionToMarkdown = NotionToMarkdown;
  }
});

// node_modules/notion-to-md/build/index.js
var require_build = __commonJS({
  "node_modules/notion-to-md/build/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_notion_to_md(), exports);
  }
});
export default require_build();
/*! Bundled license information:

repeat-string/index.js:
  (*!
   * repeat-string <https://github.com/jonschlinkert/repeat-string>
   *
   * Copyright (c) 2014-2015, Jon Schlinkert.
   * Licensed under the MIT License.
   *)
*/
//# sourceMappingURL=notion-to-md.js.map
