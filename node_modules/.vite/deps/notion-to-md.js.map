{
  "version": 3,
  "sources": ["../../repeat-string/index.js", "../../markdown-table/index.js", "../../notion-to-md/src/utils/md.ts", "../../notion-to-md/src/utils/notion.ts", "../../notion-to-md/src/notion-to-md.ts", "../../notion-to-md/src/index.ts"],
  "sourcesContent": ["/*!\n * repeat-string <https://github.com/jonschlinkert/repeat-string>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\n/**\n * Results cache\n */\n\nvar res = '';\nvar cache;\n\n/**\n * Expose `repeat`\n */\n\nmodule.exports = repeat;\n\n/**\n * Repeat the given `string` the specified `number`\n * of times.\n *\n * **Example:**\n *\n * ```js\n * var repeat = require('repeat-string');\n * repeat('A', 5);\n * //=> AAAAA\n * ```\n *\n * @param {String} `string` The string to repeat\n * @param {Number} `number` The number of times to repeat the string\n * @return {String} Repeated string\n * @api public\n */\n\nfunction repeat(str, num) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  // cover common, quick use cases\n  if (num === 1) return str;\n  if (num === 2) return str + str;\n\n  var max = str.length * num;\n  if (cache !== str || typeof cache === 'undefined') {\n    cache = str;\n    res = '';\n  } else if (res.length >= max) {\n    return res.substr(0, max);\n  }\n\n  while (max > res.length && num > 1) {\n    if (num & 1) {\n      res += str;\n    }\n\n    num >>= 1;\n    str += str;\n  }\n\n  res += str;\n  res = res.substr(0, max);\n  return res;\n}\n", "'use strict'\n\nvar repeat = require('repeat-string')\n\nmodule.exports = markdownTable\n\nvar trailingWhitespace = / +$/\n\n// Characters.\nvar space = ' '\nvar lineFeed = '\\n'\nvar dash = '-'\nvar colon = ':'\nvar verticalBar = '|'\n\nvar x = 0\nvar C = 67\nvar L = 76\nvar R = 82\nvar c = 99\nvar l = 108\nvar r = 114\n\n// Create a table from a matrix of strings.\nfunction markdownTable(table, options) {\n  var settings = options || {}\n  var padding = settings.padding !== false\n  var start = settings.delimiterStart !== false\n  var end = settings.delimiterEnd !== false\n  var align = (settings.align || []).concat()\n  var alignDelimiters = settings.alignDelimiters !== false\n  var alignments = []\n  var stringLength = settings.stringLength || defaultStringLength\n  var rowIndex = -1\n  var rowLength = table.length\n  var cellMatrix = []\n  var sizeMatrix = []\n  var row = []\n  var sizes = []\n  var longestCellByColumn = []\n  var mostCellsPerRow = 0\n  var cells\n  var columnIndex\n  var columnLength\n  var largest\n  var size\n  var cell\n  var lines\n  var line\n  var before\n  var after\n  var code\n\n  // This is a superfluous loop if we don’t align delimiters, but otherwise we’d\n  // do superfluous work when aligning, so optimize for aligning.\n  while (++rowIndex < rowLength) {\n    cells = table[rowIndex]\n    columnIndex = -1\n    columnLength = cells.length\n    row = []\n    sizes = []\n\n    if (columnLength > mostCellsPerRow) {\n      mostCellsPerRow = columnLength\n    }\n\n    while (++columnIndex < columnLength) {\n      cell = serialize(cells[columnIndex])\n\n      if (alignDelimiters === true) {\n        size = stringLength(cell)\n        sizes[columnIndex] = size\n\n        largest = longestCellByColumn[columnIndex]\n\n        if (largest === undefined || size > largest) {\n          longestCellByColumn[columnIndex] = size\n        }\n      }\n\n      row.push(cell)\n    }\n\n    cellMatrix[rowIndex] = row\n    sizeMatrix[rowIndex] = sizes\n  }\n\n  // Figure out which alignments to use.\n  columnIndex = -1\n  columnLength = mostCellsPerRow\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < columnLength) {\n      alignments[columnIndex] = toAlignment(align[columnIndex])\n    }\n  } else {\n    code = toAlignment(align)\n\n    while (++columnIndex < columnLength) {\n      alignments[columnIndex] = code\n    }\n  }\n\n  // Inject the alignment row.\n  columnIndex = -1\n  columnLength = mostCellsPerRow\n  row = []\n  sizes = []\n\n  while (++columnIndex < columnLength) {\n    code = alignments[columnIndex]\n    before = ''\n    after = ''\n\n    if (code === l) {\n      before = colon\n    } else if (code === r) {\n      after = colon\n    } else if (code === c) {\n      before = colon\n      after = colon\n    }\n\n    // There *must* be at least one hyphen-minus in each alignment cell.\n    size = alignDelimiters\n      ? Math.max(\n          1,\n          longestCellByColumn[columnIndex] - before.length - after.length\n        )\n      : 1\n\n    cell = before + repeat(dash, size) + after\n\n    if (alignDelimiters === true) {\n      size = before.length + size + after.length\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size\n      }\n\n      sizes[columnIndex] = size\n    }\n\n    row[columnIndex] = cell\n  }\n\n  // Inject the alignment row.\n  cellMatrix.splice(1, 0, row)\n  sizeMatrix.splice(1, 0, sizes)\n\n  rowIndex = -1\n  rowLength = cellMatrix.length\n  lines = []\n\n  while (++rowIndex < rowLength) {\n    row = cellMatrix[rowIndex]\n    sizes = sizeMatrix[rowIndex]\n    columnIndex = -1\n    columnLength = mostCellsPerRow\n    line = []\n\n    while (++columnIndex < columnLength) {\n      cell = row[columnIndex] || ''\n      before = ''\n      after = ''\n\n      if (alignDelimiters === true) {\n        size = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)\n        code = alignments[columnIndex]\n\n        if (code === r) {\n          before = repeat(space, size)\n        } else if (code === c) {\n          if (size % 2 === 0) {\n            before = repeat(space, size / 2)\n            after = before\n          } else {\n            before = repeat(space, size / 2 + 0.5)\n            after = repeat(space, size / 2 - 0.5)\n          }\n        } else {\n          after = repeat(space, size)\n        }\n      }\n\n      if (start === true && columnIndex === 0) {\n        line.push(verticalBar)\n      }\n\n      if (\n        padding === true &&\n        // Don’t add the opening space if we’re not aligning and the cell is\n        // empty: there will be a closing space.\n        !(alignDelimiters === false && cell === '') &&\n        (start === true || columnIndex !== 0)\n      ) {\n        line.push(space)\n      }\n\n      if (alignDelimiters === true) {\n        line.push(before)\n      }\n\n      line.push(cell)\n\n      if (alignDelimiters === true) {\n        line.push(after)\n      }\n\n      if (padding === true) {\n        line.push(space)\n      }\n\n      if (end === true || columnIndex !== columnLength - 1) {\n        line.push(verticalBar)\n      }\n    }\n\n    line = line.join('')\n\n    if (end === false) {\n      line = line.replace(trailingWhitespace, '')\n    }\n\n    lines.push(line)\n  }\n\n  return lines.join(lineFeed)\n}\n\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value)\n}\n\nfunction defaultStringLength(value) {\n  return value.length\n}\n\nfunction toAlignment(value) {\n  var code = typeof value === 'string' ? value.charCodeAt(0) : x\n\n  return code === L || code === l\n    ? l\n    : code === R || code === r\n    ? r\n    : code === C || code === c\n    ? c\n    : x\n}\n", "import { CalloutIcon } from \"../types\";\nimport markdownTable from \"markdown-table\";\n\nexport const inlineCode = (text: string) => {\n  return `\\`${text}\\``;\n};\n\nexport const inlineEquation = (text: string) => {\n  return `$${text}$`;\n};\n\nexport const bold = (text: string) => {\n  return `**${text}**`;\n};\n\nexport const italic = (text: string) => {\n  return `_${text}_`;\n};\n\nexport const strikethrough = (text: string) => {\n  return `~~${text}~~`;\n};\n\nexport const underline = (text: string) => {\n  return `<u>${text}</u>`;\n};\n\nexport const link = (text: string, href: string) => {\n  return `[${text}](${href})`;\n};\n\nexport const codeBlock = (text: string, language?: string) => {\n  if (language === \"plain text\") language = \"text\";\n\n  return `\\`\\`\\`${language}\n${text}\n\\`\\`\\``;\n};\n\nexport const equation = (text: string) => {\n  return `$$\n${text}\n$$`;\n};\n\nexport const heading1 = (text: string) => {\n  return `# ${text}`;\n};\n\nexport const heading2 = (text: string) => {\n  return `## ${text}`;\n};\n\nexport const heading3 = (text: string) => {\n  return `### ${text}`;\n};\n\nexport const quote = (text: string) => {\n  // the replace is done to handle multiple lines\n  return `> ${text.replace(/\\n/g, \"  \\n> \")}`;\n};\n\nexport const callout = (text: string, icon?: CalloutIcon) => {\n  let emoji: string | undefined;\n  if (icon?.type === \"emoji\") {\n    emoji = icon.emoji;\n  }\n\n  // the replace is done to handle multiple lines\n  return `> ${emoji ? emoji + \" \" : \"\"}${text.replace(/\\n/g, \"  \\n> \")}`;\n};\n\nexport const bullet = (text: string, count?: number) => {\n  let renderText = text.trim();\n  return count ? `${count}. ${renderText}` : `- ${renderText}`;\n};\n\nexport const todo = (text: string, checked: boolean) => {\n  return checked ? `- [x] ${text}` : `- [ ] ${text}`;\n};\n\nexport const image = (alt: string, href: string) => {\n  return `![${alt}](${href})`;\n};\n\nexport const addTabSpace = (text: string, n = 0) => {\n  const tab = \"\t\";\n  for (let i = 0; i < n; i++) {\n    if (text.includes(\"\\n\")) {\n      const multiLineText = text.split(/(?:^|\\n)/).join(`\\n${tab}`);\n      text = tab + multiLineText;\n    } else text = tab + text;\n  }\n  return text;\n};\n\nexport const divider = () => {\n  return \"---\";\n};\n\nexport const toggle = (summary?: string, children?: string) => {\n  if (!summary) return children || \"\";\n  return `<details>\n  <summary>${summary}</summary>\n\n${children || \"\"}\n\n  </details>`;\n};\n\nexport const table = (cells: string[][]) => {\n  return markdownTable(cells);\n};\n", "import { Client } from \"@notionhq/client\";\nimport { ListBlockChildrenResponse } from \"@notionhq/client/build/src/api-endpoints\";\nimport { ListBlockChildrenResponseResults } from \"../types\";\n\nexport const getBlockChildren = async (\n  notionClient: Client,\n  block_id: string,\n  totalPage: number | null\n) => {\n  try {\n    let result: ListBlockChildrenResponseResults = [];\n    let pageCount = 0;\n    let start_cursor = undefined;\n\n    do {\n      const response = (await notionClient.blocks.children.list({\n        start_cursor: start_cursor,\n        block_id: block_id,\n      })) as ListBlockChildrenResponse;\n      result.push(...response.results);\n\n      start_cursor = response?.next_cursor;\n      pageCount += 1;\n    } while (\n      start_cursor != null &&\n      (totalPage == null || pageCount < totalPage)\n    );\n\n    modifyNumberedListObject(result);\n    return result;\n  } catch (e) {\n    console.log(e);\n    return [];\n  }\n};\n\nexport const modifyNumberedListObject = (\n  blocks: ListBlockChildrenResponseResults\n) => {\n  let numberedListIndex = 0;\n\n  for (const block of blocks) {\n    if (\"type\" in block && block.type === \"numbered_list_item\") {\n      // add numbers\n      // @ts-ignore\n      block.numbered_list_item.number = ++numberedListIndex;\n    } else {\n      numberedListIndex = 0;\n    }\n  }\n};\n", "import { Client } from \"@notionhq/client\";\n\nimport {\n  Annotations,\n  CustomTransformer,\n  ListBlockChildrenResponseResult,\n  ListBlockChildrenResponseResults,\n  MdBlock,\n  NotionToMarkdownOptions,\n  Equation,\n  Text,\n  ConfigurationOptions,\n  MdStringObject,\n} from \"./types\";\nimport * as md from \"./utils/md\";\nimport { getBlockChildren } from \"./utils/notion\";\n\n/**\n * Converts a Notion page to Markdown.\n */\nexport class NotionToMarkdown {\n  private notionClient: Client;\n  private config: ConfigurationOptions;\n  private targetPage: string;\n  private customTransformers: Record<string, CustomTransformer>;\n\n  constructor(options: NotionToMarkdownOptions) {\n    this.notionClient = options.notionClient;\n    const defaultConfig: ConfigurationOptions = {\n      separateChildPage: false,\n    };\n    this.targetPage = \"\";\n    this.config = { ...defaultConfig, ...options.config };\n    this.customTransformers = {};\n  }\n\n  setCustomTransformer(\n    type: string,\n    transformer: CustomTransformer\n  ): NotionToMarkdown {\n    this.customTransformers[type] = transformer;\n\n    return this;\n  }\n\n  /**\n   * Converts Markdown Blocks to string\n   * @param {MdBlock[]} mdBlocks - Array of markdown blocks\n   * @param {number} nestingLevel - Defines max depth of nesting\n   * @returns {MdStringObject} - Returns markdown string with child pages separated\n   */\n  toMarkdownString(\n    mdBlocks: MdBlock[] = [],\n    pageIdentifier: string = \"parent\",\n    nestingLevel: number = 0\n  ): MdStringObject {\n    let mdOutput: MdStringObject = {};\n\n    mdBlocks.forEach((mdBlocks) => {\n      // NOTE: toggle in the child blocks logic\n      // adding a toggle check prevents duplicate\n      // rendering of toggle title\n\n      // process parent blocks\n      if (\n        mdBlocks.parent &&\n        mdBlocks.type !== \"toggle\" &&\n        mdBlocks.type !== \"child_page\"\n      ) {\n        if (\n          mdBlocks.type !== \"to_do\" &&\n          mdBlocks.type !== \"bulleted_list_item\" &&\n          mdBlocks.type !== \"numbered_list_item\"\n        ) {\n          // initialize if key doesn't exist\n          mdOutput[pageIdentifier] = mdOutput[pageIdentifier] || \"\";\n\n          // add extra line breaks non list blocks\n          mdOutput[pageIdentifier] += `\\n${md.addTabSpace(\n            mdBlocks.parent,\n            nestingLevel\n          )}\\n\\n`;\n        } else {\n          // initialize if key doesn't exist\n          mdOutput[pageIdentifier] = mdOutput[pageIdentifier] || \"\";\n\n          mdOutput[pageIdentifier] += `${md.addTabSpace(\n            mdBlocks.parent,\n            nestingLevel\n          )}\\n`;\n        }\n      }\n\n      // process child blocks\n      if (mdBlocks.children && mdBlocks.children.length > 0) {\n        if (\n          mdBlocks.type === \"synced_block\" ||\n          mdBlocks.type === \"column_list\" ||\n          mdBlocks.type === \"column\"\n        ) {\n          let mdstr = this.toMarkdownString(mdBlocks.children, pageIdentifier);\n          // mdOutput[pageIdentifier] += mdstr[pageIdentifier];\n          mdOutput[pageIdentifier] = mdOutput[pageIdentifier] || \"\";\n\n          Object.keys(mdstr).forEach((key) => {\n            if (mdOutput[key]) {\n              mdOutput[key] + mdstr[key];\n            } else {\n              mdOutput[key] = mdstr[key];\n            }\n          });\n          mdOutput[pageIdentifier] += mdstr[pageIdentifier];\n\n          // mdOutput = { ...mdOutput, ...mdstr };\n        } else if (mdBlocks.type === \"child_page\") {\n          const childPageTitle = mdBlocks.parent;\n          let mdstr = this.toMarkdownString(mdBlocks.children, childPageTitle);\n\n          if (this.config.separateChildPage) {\n            // console.log(\"<<\", mdOutput, mdstr);\n            mdOutput = { ...mdOutput, ...mdstr };\n            // console.log(\">>\", mdOutput, \"\\n\\n\");\n          } else {\n            mdOutput[pageIdentifier] += mdstr[childPageTitle];\n          }\n        } else if (mdBlocks.type === \"toggle\") {\n          // convert children md object to md string\n          const toggle_children_md_string = this.toMarkdownString(\n            mdBlocks.children\n          );\n\n          mdOutput[pageIdentifier] += md.toggle(\n            mdBlocks.parent,\n            toggle_children_md_string[\"parent\"]\n          );\n        } else {\n          let mdstr = this.toMarkdownString(\n            mdBlocks.children,\n            pageIdentifier,\n            nestingLevel + 1\n          );\n\n          mdOutput[pageIdentifier] += mdstr[\"parent\"];\n        }\n      }\n    });\n\n    return mdOutput;\n  }\n\n  /**\n   * Retrieves Notion Blocks based on ID and converts them to Markdown Blocks\n   * @param {string} id - notion page id (not database id)\n   * @param {number} totalPage - Retrieve block children request number, page_size Maximum = totalPage * 100 (Default=null)\n   * @returns {Promise<MdBlock[]>} - List of markdown blocks\n   */\n  async pageToMarkdown(\n    id: string,\n    totalPage: number | null = null\n  ): Promise<MdBlock[]> {\n    if (!this.notionClient) {\n      throw new Error(\n        \"notion client is not provided, for more details check out https://github.com/souvikinator/notion-to-md\"\n      );\n    }\n    this.targetPage = id;\n    const blocks = await getBlockChildren(this.notionClient, id, totalPage);\n\n    const parsedData = await this.blocksToMarkdown(blocks);\n\n    return parsedData;\n  }\n\n  /**\n   * Converts list of Notion Blocks to Markdown Blocks\n   * @param {ListBlockChildrenResponseResults | undefined} blocks - List of notion blocks\n   * @param {number} totalPage - Retrieve block children request number, page_size Maximum = totalPage * 100\n   * @param {MdBlock[]} mdBlocks - Defines max depth of nesting\n   * @returns {Promise<MdBlock[]>} - Array of markdown blocks with their children\n   */\n  async blocksToMarkdown(\n    blocks?: ListBlockChildrenResponseResults,\n    totalPage: number | null = null,\n    mdBlocks: MdBlock[] = []\n  ): Promise<MdBlock[]> {\n    if (!this.notionClient) {\n      throw new Error(\n        \"notion client is not provided, for more details check out https://github.com/souvikinator/notion-to-md\"\n      );\n    }\n\n    if (!blocks) return mdBlocks;\n\n    for (let i = 0; i < blocks.length; i++) {\n      let block = blocks[i];\n\n      if (\"has_children\" in block && block.has_children) {\n        // Get children of this block.\n        let child_blocks = await getBlockChildren(\n          this.notionClient,\n          block.id,\n          totalPage\n        );\n\n        // Push this block to mdBlocks.\n        mdBlocks.push({\n          type: block.type,\n          blockId: block.id,\n          parent: await this.blockToMarkdown(block),\n          children: [],\n        });\n\n        // Recursively call blocksToMarkdown to get children of this block.\n        let l = mdBlocks.length;\n        await this.blocksToMarkdown(\n          child_blocks,\n          totalPage,\n          mdBlocks[l - 1].children\n        );\n        continue;\n      }\n\n      let tmp = await this.blockToMarkdown(block);\n      mdBlocks.push({\n        // @ts-ignore\n        type: block.type,\n        blockId: block.id,\n        parent: tmp,\n        children: [],\n      });\n    }\n    return mdBlocks;\n  }\n\n  /**\n   * Converts a Notion Block to a Markdown Block\n   * @param {ListBlockChildrenResponseResult} block - single notion block\n   * @returns {string} corresponding markdown string of the passed block\n   */\n  async blockToMarkdown(block: ListBlockChildrenResponseResult) {\n    if (typeof block !== \"object\" || !(\"type\" in block)) return \"\";\n\n    let parsedData = \"\";\n    const { type } = block;\n    if (type in this.customTransformers && !!this.customTransformers[type]) {\n      const customTransformerValue = await this.customTransformers[type](block);\n      if (!!customTransformerValue || customTransformerValue === \"\")\n        return customTransformerValue;\n    }\n\n    switch (type) {\n      case \"image\":\n        {\n          let blockContent = block.image;\n\n          const image_caption_plain = blockContent.caption\n            .map((item: any) => item.plain_text)\n            .join(\"\");\n\n          const image_type = blockContent.type;\n\n          if (image_type === \"external\")\n            return md.image(image_caption_plain, blockContent.external.url);\n\n          if (image_type === \"file\")\n            return md.image(image_caption_plain, blockContent.file.url);\n        }\n        break;\n\n      case \"divider\": {\n        return md.divider();\n      }\n\n      case \"equation\": {\n        return md.equation(block.equation.expression);\n      }\n\n      case \"video\":\n      case \"file\":\n      case \"pdf\":\n        {\n          let blockContent;\n          if (type === \"video\") blockContent = block.video;\n          if (type === \"file\") blockContent = block.file;\n          if (type === \"pdf\") blockContent = block.pdf;\n          if (blockContent) {\n            const file_type = blockContent.type;\n            if (file_type === \"external\")\n              return md.link(\"image\", blockContent.external.url);\n            if (file_type === \"file\")\n              return md.link(\"image\", blockContent.file.url);\n          }\n        }\n        break;\n\n      case \"bookmark\":\n      case \"embed\":\n      case \"link_preview\":\n      case \"link_to_page\":\n        {\n          let blockContent;\n          let title: string = type;\n          if (type === \"bookmark\") blockContent = block.bookmark;\n          if (type === \"embed\") blockContent = block.embed;\n          if (type === \"link_preview\") blockContent = block.link_preview;\n          if (\n            type === \"link_to_page\" &&\n            block.link_to_page.type === \"page_id\"\n          ) {\n            blockContent = { url: block.link_to_page.page_id };\n          }\n\n          if (blockContent) return md.link(title, blockContent.url);\n        }\n        break;\n\n      case \"child_page\":\n        {\n          let pageTitle: string = block.child_page.title;\n\n          if (this.config.separateChildPage) {\n            return pageTitle;\n          }\n\n          return md.heading2(pageTitle);\n        }\n        break;\n      case \"child_database\":\n        {\n          let pageTitle = block.child_database.title || `child_database`;\n          return pageTitle;\n        }\n        break;\n\n      case \"table\": {\n        const { id, has_children } = block;\n        let tableArr: string[][] = [];\n        if (has_children) {\n          const tableRows = await getBlockChildren(this.notionClient, id, 100);\n          let rowsPromise = tableRows?.map(async (row) => {\n            const { type } = row as any;\n            const cells = (row as any)[type][\"cells\"];\n\n            /**\n             * this is more like a hack since matching the type text was\n             * difficult. So converting each cell to paragraph type to\n             * reuse the blockToMarkdown function\n             */\n            let cellStringPromise = cells.map(\n              async (cell: any) =>\n                await this.blockToMarkdown({\n                  type: \"paragraph\",\n                  paragraph: { rich_text: cell },\n                } as ListBlockChildrenResponseResult)\n            );\n\n            const cellStringArr = await Promise.all(cellStringPromise);\n            tableArr.push(cellStringArr);\n          });\n          await Promise.all(rowsPromise || []);\n        }\n        return md.table(tableArr);\n      }\n      // Rest of the types\n      // \"paragraph\"\n      // \"heading_1\"\n      // \"heading_2\"\n      // \"heading_3\"\n      // \"bulleted_list_item\"\n      // \"numbered_list_item\"\n      // \"quote\"\n      // \"to_do\"\n      // \"template\"\n      // \"synced_block\"\n      // \"child_page\"\n      // \"child_database\"\n      // \"code\"\n      // \"callout\"\n      // \"breadcrumb\"\n      // \"table_of_contents\"\n      // \"link_to_page\"\n      // \"audio\"\n      // \"unsupported\"\n\n      default: {\n        // In this case typescript is not able to index the types properly, hence ignoring the error\n        // @ts-ignore\n        let blockContent = block[type].text || block[type].rich_text || [];\n        blockContent.map((content: Text | Equation) => {\n          if (content.type === \"equation\") {\n            parsedData += md.inlineEquation(content.equation.expression);\n            return;\n          }\n\n          const annotations = content.annotations;\n          let plain_text = content.plain_text;\n\n          plain_text = this.annotatePlainText(plain_text, annotations);\n\n          if (content[\"href\"])\n            plain_text = md.link(plain_text, content[\"href\"]);\n\n          parsedData += plain_text;\n        });\n      }\n    }\n\n    switch (type) {\n      case \"code\":\n        {\n          parsedData = md.codeBlock(parsedData, block[type].language);\n        }\n        break;\n\n      case \"heading_1\":\n        {\n          parsedData = md.heading1(parsedData);\n        }\n        break;\n\n      case \"heading_2\":\n        {\n          parsedData = md.heading2(parsedData);\n        }\n        break;\n\n      case \"heading_3\":\n        {\n          parsedData = md.heading3(parsedData);\n        }\n        break;\n\n      case \"quote\":\n        {\n          parsedData = md.quote(parsedData);\n        }\n        break;\n\n      case \"callout\":\n        {\n          const { id, has_children } = block;\n          let callout_string = \"\";\n\n          if (!has_children) {\n            return md.callout(parsedData, block[type].icon);\n          }\n\n          const callout_children_object = await getBlockChildren(\n            this.notionClient,\n            id,\n            100\n          );\n\n          // // parse children blocks to md object\n          const callout_children = await this.blocksToMarkdown(\n            callout_children_object\n          );\n\n          callout_string += `${parsedData}\\n`;\n          callout_children.map((child) => {\n            callout_string += `${child.parent}\\n\\n`;\n          });\n\n          parsedData = md.callout(callout_string.trim(), block[type].icon);\n        }\n        break;\n\n      case \"bulleted_list_item\":\n        {\n          parsedData = md.bullet(parsedData);\n        }\n        break;\n\n      case \"numbered_list_item\":\n        {\n          parsedData = md.bullet(parsedData, block.numbered_list_item.number);\n        }\n        break;\n\n      case \"to_do\":\n        {\n          parsedData = md.todo(parsedData, block.to_do.checked);\n        }\n        break;\n    }\n\n    return parsedData;\n  }\n\n  /**\n   * Annoate text using provided annotations\n   * @param {string} text - String to be annotated\n   * @param {Annotations} annotations - Annotation object of a notion block\n   * @returns {string} - Annotated text\n   */\n  annotatePlainText(text: string, annotations: Annotations): string {\n    // if text is all spaces, don't annotate\n    if (text.match(/^\\s*$/)) return text;\n\n    const leadingSpaceMatch = text.match(/^(\\s*)/);\n    const trailingSpaceMatch = text.match(/(\\s*)$/);\n\n    const leading_space = leadingSpaceMatch ? leadingSpaceMatch[0] : \"\";\n    const trailing_space = trailingSpaceMatch ? trailingSpaceMatch[0] : \"\";\n\n    text = text.trim();\n\n    if (text !== \"\") {\n      if (annotations.code) text = md.inlineCode(text);\n      if (annotations.bold) text = md.bold(text);\n      if (annotations.italic) text = md.italic(text);\n      if (annotations.strikethrough) text = md.strikethrough(text);\n      if (annotations.underline) text = md.underline(text);\n    }\n\n    return leading_space + text + trailing_space;\n  }\n}\n", "export * from \"./notion-to-md\";\n"],
  "mappings": "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",
  "names": ["mdBlocks", "type"]
}
